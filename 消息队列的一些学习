1.为什么使用消息队列？
使用消息队列的场景有很多，比较核心的有3个：异步、解耦、削峰与流控、广播（减少接口调用和联调）。
Web前端每秒承受上千万的请求，并不是什么神奇的事情，只需要加多一点机器，再搭建一些LVS负载均衡设备和Nginx等即可。
但数据库的处理能力却十分有限，即使使用SSD加分库分表，单机的处理能力仍然在万级。由于成本的考虑，我们不能奢求数据库的机器数量追上前端。

2.消息队列有啥缺点？
（1）系统可用性降低
系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？
（2）系统复杂度提高
硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？
（3）一致性问题
A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，怎么办？你这数据就不一致了。

3.Rocket MQ和Kafka MQ的对比
（1）单机吞吐量都可以达到10W级；Kafka一般应用在大数据实时计算、日志采集等场景下
（2）延迟都在ms级；
（3）Rocket MQ支持的topic可以达到几百到几千，但是吞吐量会有一定下降；Kafka MQ支持的topic从几十上升到几百，吞吐率会有大幅度下降，需要保证topic不要过多；
（4）可用性方面，都是分布式，多副本，经过参数配置，消息可以做到0丢失；

4.如何设计一个消息队列？
基于消息的系统模型，不一定需要broker(消息队列服务端)。市面上的的Akka（actor模型）、ZeroMQ等，其实都是基于消息的系统设计范式，但是没有broker。
我们之所以要设计一个消息队列，并且配备broker，无外乎要做两件事情：
（1）消息的转储，在更合适的时间点投递，或者通过一系列手段辅助消息最终能送达消费机。
（2）规范一种范式和通用的模式，以满足解耦、最终一致性、错峰等需求。
（3）最简单的消息队列可以做成一个消息转发器，把一次RPC做成两次RPC。发送者把消息投递到服务端（以下简称broker），服务端再将消息转发一手到接收端，就是这么简单。

一般来讲，设计消息队列的整体思路是：
（1）先build一个整体的数据流，例如producer发送给broker，broker发送给consumer，consumer回复消费确认，broker删除/备份消息等。
（2）再利用RPC将数据流串起来，然后考虑RPC的高可用性，尽量做到无状态，方便水平扩展。
（3）之后考虑如何承载消息堆积，然后在合适的时机投递消息，而处理堆积的最佳方式，就是存储，存储的选型需要综合考虑性能/可靠性和开发维护成本等诸多因素。
（4）为了实现广播功能，我们必须要维护消费关系，可以利用zk/config server等保存消费关系。
在完成了上述几个功能后，消息队列基本就实现了。
然后我们可以考虑一些高级特性，如可靠投递，事务特性，性能优化等。

