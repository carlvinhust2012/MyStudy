既然有 HTTP 请求，为什么还要用 RPC 调用？
http 协议还是面向桌面浏览器的广域网的一个通信协议，在缓存、幂等重试乃至 Cookie 这种浏览器安全相关的方面做了很多功夫。
rpc 协议就主要在注册发现、监控、负载均衡、熔断降级方面上做功夫，重要的是标准化。rpc 协议也可以选择建在 http/http2 之上，有现成的 nginx、curl 之类工具可以用。

首先 RPC 框架配置复杂，如果走 HTTP 请求同样也能做到相同功能，而且配置可以几乎为零配置，项目也不用引用太多的包。
虽然如果单纯用 RPC，可以不用类似于 Servlet 的 Web 标准。

通信协议不是rpc最重要的部分，不要被这个回答带偏了。如果要了解rpc请更多的去了解服务治理(soa)的一些基本策略,推荐去看看dubbo的文档。
这个问题其实是有理解误区的，首先 http 和 rpc 并不是一个并行概念。rpc是远端过程调用，其调用协议通常包含传输协议和序列化协议。
传输协议包含: 如著名的 [gRPC](grpc / grpc.io) 使用的 http2 协议，也有如dubbo一类的自定义报文的tcp协议。序列化协议包含: 如基于文本编码的 xml json，也有二进制编码的 protobuf hessian等。

因此我理解的你想问的问题应该是：为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？
要解决这个问题就应该搞清楚 http 使用的 tcp 协议，和我们自定义的 tcp 协议在报文上的区别。
首先要否认一点 http 协议相较于自定义tcp报文协议，增加的开销在于连接的建立与断开。http协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。
二要说的是http也可以使用protobuf这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。

RPC要求在调用方中放置被调用的方法的接口。
调用方只要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用。于是，调用方可以像调用内部接口一样调用远程的方法，而不用封装参数名和参数值等操作。

那要想实现这个过程该怎么办呢？
1. 调用方调用的是接口，必须得为接口构造一个假的实现。显然，要使用动态代理，这样，调用方的调用就被动态代理接收到了。
2. 动态代理接收到调用后，应该想办法调用远程的实际实现。这包括下面几步：识别具体要调用的远程方法的IP、端口将调用方法的入参进行序列化通过通信将请求发送到远程的方法中这样，
远程的服务就接收到了调用方的请求。它应该：反序列化各个调用参数定位到实际要调用的方法，然后输入参数，执行方法按照调用的路径返回调用的结果。
