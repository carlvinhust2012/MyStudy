3FS 的 metad 进程 在收到任何 POSIX 调用（open/unlink/stat...）后的 第一步 就是 把路径名解析成 inode，然后 后续所有内部操作都只用 inode。
下面给出一次 open("/a/b/c.txt", O_RDONLY) 的完整“路径→inode”时序图

Client(app)        lib3fs/fuse        metad-0        metad-1        FDB KV
     |                  |               |              |              |
     | 1. open("/a/b/c.txt", O_RDONLY)  |              |              |
     |----------------->|               |              |              |
     |                  | 2. 逐级解析请求                               |
     |                  |---------------|--------------|              |
     |                  |               | 3. 查根 inode(固定=1)        |
     |                  |               |---------------------------->|
     |                  |               | 4. 读 /a 的 dentry           |
     |                  |               |<----------------------------|
     |                  |               | 5. 得到 /a 的 inode=100      |
     |                  |               | 6. 读 /a/b 的 dentry         |
     |                  |               |---------------------------->|
     |                  |               | 7. 得到 /b 的 inode=101      |
     |                  |               | 8. 读 /a/b/c.txt dentry     |
     |                  |               |---------------------------->|
     |                  |               | 9. 得到 c.txt inode=102      |
     |                  |               | 10. 读 inode-102 属性        |
     |                  |               |---------------------------->|
     |                  |               | 11. 返回 inode+attr          |
     |                  |<--------------|--------------|              |
     |                  | 12. 缓存在 lib 内存(dentry cache 30 s)        |  
     |<-----------------|               |              |              |

1）路径解析完全在 metad 内部完成，客户端拿不到中间 inode，只能拿到 最终 inode 与 attr。
2）解析算法就是 字符串 split('/') + 逐级 FDB GetRange，利用 同一父目录的 dentry key 连续 的特性，一次范围扫描 即可拿到所有子项，O(depth) 次 RPC 即可到底。
3）解析成功后，lib3fs 会把 “最后一级 dentry → inode” 记入本地 LRU dentry cache（默认 30 s），后续 open/read/write 直接传 inode，不再重复解析。
4）如果 cache 命中，路径→inode 转换成本 = 0；未命中则再走一次上图流程。
因此，3FS 确实先把 path/filename 转换成 inode，之后所有内部元数据读写都围绕 inode 展开，路径只在客户端第一次接触文件时有用。

client(lib3fs)              FDB(metad)                        storaged-0        storaged-1
     |                           |                                 |                |
     | 1. open/write("/a/b/c", buf, len)                           |                |
     |---- 本地 dentry 缓存命中，已拿到 inode=102 & attr ---          |                |
     |                                                             |                |
     | 2. 计算 chunk_id = offset >> 26 (64 MiB)                     |                |
     |    hash_key = xxhash(inode, chunk_id, seed)                 |                |
     |    primary = skiplist[hash_key]  // 0 RTT                   |                |
     |------------------------------------------------------------>|                |
     | 3. RDMA_WRITE chunk0 to storaged-0 (主副本)                  |                |
     |<------------------------------------------------------------|                |
     | 4. storaged-0 后台链式复制(CRAQ) 给 storaged-1/2              |--------------->|
     | 5. 多数派落盘后，回 ACK                                       |<---------------|
     | 6. client 收到 ACK，write() 返回成功                          |                |

一、核心数据结构（attr 里自带“路由种子”）
| 字段            | 长度 | 说明                     |
| -------------- | --- | ------------------------ |
| `chunk_size`   | 4 B | 创建文件时选定，默认 64 MiB |
| `stripe_width` | 2 B | 副本数，默认 3             |
| `hash_seed`    | 8 B | 文件级随机种子，防止全局热点 |

二、客户端计算路由（0 RTT）
1）逻辑 chunk 编号
chunk_id = offset >> chunk_size_bits
（即 offset / chunk_size，向下取整）
2）一致性哈希键
hash_key = hash(inode, chunk_id, hash_seed)
采用 xxHash64，确定性 且 均匀。
3）选主副本节点
把 hash_key 扔进 跳表（Skiplist）环，环上节点按 node_id 排序；
顺时针取 前 stripe_width 个 node_id，即为 主→备→备 列表。
复杂度 O(log N)，纯本地 CPU 计算，0 网络 RTT。
4）物理地址拼装
storaged_endpoint = node_id_to_rdma_addr(node_id)
chunk_handle = {inode, chunk_id}
客户端直接 RDMA_WRITE(buf, endpoint, chunk_handle)。

读流程同理
chunk_id = offset >> 26
hash_key = xxhash(inode, chunk_id, seed)
node_list = skiplist[hash_key]  // 0 RTT
pick = node_list[0]             // 优先本地/同机架
RDMA_READ(chunk_handle, pick)

为什么 chunk_id = offset >> 26 ？
64 MiB = 2^26 B ⇒ 用 offset >> 26 就能 零开销地 算出“从文件头开始第几个 64 MiB 块”，比除法快、且编译器常量折叠后只剩一条移位指令


3FS 自己不“建表”，而是把 所有元数据映射成 FoundationDB 里的 KV 对；
整个命名空间只用 两类前缀（\x01 dentry、\x02 inode）就搞定 POSIX 语义，没有独立的“表”概念，但可按 key 前缀 把逻辑视图看成 4 张表。
下面给出 key 拼写规则 + value 内容 + 典型长度，一眼就能对照源码
| # | 前缀     | 逻辑表名     | key 拼装格式（二进制）                   | 说明                                     |
| - | ------ | ------------ | ------------------------------------- | --------------------------------------  |
| 1 | `\x01` | dentry       | `\x01{parent_inode BE32}{name UTF-8}` | 目录项 → inode 映射                       |
| 2 | `\x02` | inode\_attr  | `\x02{inode BE32}attr`                | 标准属性（size/mode/uid/gid/mtime/ctime） |
| 3 | `\x02` | inode\_xattr | `\x02{inode BE32}x{name}`             | 扩展属性（selinux/capability…）           |
| 4 | `\x02` | inode\_chunk | `\x02{inode BE32}c{chunk_id BE64}`    | chunk→storaged 列表（仅大文件）            |

一、key 拼装规则（二进制）
| 步骤 | 目录层级     | 实际 FDB key（hex）           | 说明                        |
| -- | ------------ | --------------------------- | -------------------------   |
| 1  | `/`          | `\x02\x00\x00\x00\x01attr`  | 根 inode 固定 = 1            |
| 2  | `/a`         | `\x01{1BE32}"a"`            | 在根目录下找 dentry "a"       |
| 3  | `/a/b`       | `\x01{parent_inode}"b"`     | parent\_inode 是上一步读出的值 |
| 4  | `/a/b/c.txt` | `\x01{parent_inode}"c.txt"` | 最终拿到目标 inode            |

二、解析流程（0 网络跳转，本地 metad 线程）
client(metad)                                      FoundationDB
     |                                                    |
     | 1. 根 inode 缓存命中？                               |
     |---- 有 → 直接拿 inode=1                              |
     |---- 无 → Get('\x02\x00\x00\x00\x01attr') → 8 B 包体 |
     |                                                    |
     | 2. 读 /a 的 dentry                                  |
     |    Get('\x01\x00\x00\x00\x01"a"') → value=12 B     |
     |    12 B 里前 4 B 就是 inode_A                       |
     |                                                    |
     | 3. 读 /a/b 的 dentry                                |
     |    Get('\x01{inode_A}"b"') → inode_B               |
     |                                                    |
     | 4. 读 /a/b/c.txt 的 dentry                          |
     |    Get('\x01{inode_B}"c.txt"') → inode_C           |
     |                                                    |
     | 5. 读 inode_C 的 attr                               |
     |    Get('\x02{inode_C}attr') → 31 B 属性             |
     |                                                    |
     | 6. 返回 {inode_C, attr} 给客户端                     |

三、性能关键点
1）每级目录一次点查（FoundationDB 单 key 读 < 0.2 ms）。
2）同目录下有 100 万 dentry 也不影响：只读 一个 key，不是范围扫。
3）解析结果在 metad 线程本地 LRU 缓存 30 s，热路径 0 RTT。
4）深度 = 5 时，总读延迟 ≈ 5 × 0.2 ms = 1 ms；后续读写直接用 inode，不再碰路径。


Client(lib3fs)  mgmtd(master)      metad(any)  storaged-0  storaged-1  storaged-2
         |              |              |            |            |            |
         | 1. write()/fwrite()         |            |            |            |
         |---------------------------->|            |            |            |
         | 2. 获取文件句柄&路由版本       |            |            |            |
         |<----------------------------|            |            |            |
         | 3. 写请求(chunk0)            |            |            |            |
         |----------------------------------------->|            |            |
         | 4. 本地持久化(WAL)                         |            |            |
         |<-----------------------------------------|            |            |
         | 5. 链式复制(CRAQ)                                      |            |
         |------------------------------------------------------>|            |
         | 6. 链式复制                                            |----------->|
         |------------------------------------------------------------------->|
         | 7. 回写 ACK(majority=2)                                |            |
         |<------------------------------------------------------|            |
         | 8. 返回用户态成功                                        |            |
         |<------------------------------------------|           |            |
         |              ...时间流逝...                            |            |
         | 9. read()/fread()                        |            |            |
         |------------------------------------------------------>|            |
         |10. 本地命中缓存(热数据)                                  |            |
         |<------------------------------------------------------|            |
         |11. 返回数据                                             |            |
         |<------------------------------------------|           |            |

步骤说明（对照序号）
1）业务进程调用 write()，lib3fs 先拿 文件句柄 + 路由表版本号（缓存 30 s）。
2）若缓存失效，向 mgmtd master 拉取最新 chunk→storaged 列表（一致性哈希）。
3）Client 把写请求直接 RDMA 发到主副本 storaged-0（零拷贝）。
4）storaged-0 先写本地 WAL，立即给 client 返回 “已接收”（不等待复制）。
5-6. 后台 CRAQ 链式复制：0→1→2，顺序写，保证 顺序一致性。
5）当 多数派（默认 2/3） 落盘成功后，storaged-0 汇总 ACK 并回给 client。
6）Client 收到 ACK，内核返回 write() 成功；此时数据已 持久化冗余。
7）后续 读请求 同样通过一致性哈希定位到 storaged-0。
8）若数据仍在 内存 PageCache（3FS 默认 1 GB 热区），直接 零拷贝 RDMA 返回。
9）Client 把数据拷到用户缓冲区，read() 返回，一次读写闭环完成。
