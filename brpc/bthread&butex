由于brpc中引入了bthread，如果在bthread中使用了mutex，那么将会挂起当前pthread，导致该bthread_worker无法执行其他bthread，
因此类似pthread和futex的关系，brpc引入butex来实现bthread粒度的挂起和唤醒。

首先看下butex中使用到的FastPthreadMutex，FastPthreadMutex是基于futex实现的pthread粒度的锁，
当竞争不激烈时，lock和unlock操作都是通过修改一个用户态的atomic来实现，只有当竞争激烈的时候才会陷入内核进行挂起和wake。
不过互斥锁也是这么实现的，不是太理解重新实现一个的目的…
bool FastPthreadMutex::try_lock() {
    auto split = (bthread::MutexInternal*)&_futex;
    bool lock = !split->locked.exchange(1, butil::memory_order_acquire);
    if (lock) {
        PTHREAD_MUTEX_SET_OWNER(_owner);
        ADD_TLS_PTHREAD_LOCK_COUNT;
    }
    return lock;
}

void FastPthreadMutex::lock() {
    if (try_lock()) {
        return;
    }

    PTHREAD_MUTEX_CHECK_OWNER(_owner);
    (void)lock_contended(NULL);
}

如果开启了BTHREAD_USE_FAST_PTHREAD_MUTEX宏定义，使用的是FastPthreadMutex，否则使用pthread_mutex_t。
首先看下lock方法
