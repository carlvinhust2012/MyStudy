juicefs是一个基于对象存储底座的文件系统，因其兼具对象存储的低成本和完整posix语义而受众多用户喜爱，同时易于支持完备的客户端缓存，在AI训练场景尤其出众。

写流程
fileSystem.Write(in fuse.WriteIn, data []byte)
  -> VFS.Write(Ino(in.NodeId), buf, in.Offset, in.Fh) // Offset是file的offset
    -> handle.fileWriter.Write(off, buf) // off是file的offset
      -> fileWriter.writeChunk(indx, off, data) // indx表示chunk在file中的编号, off表示chunk中的offset
          -> chunkWriter.findWritableSlice(off) // off表示chunk中的offset, 为支持合并写, 将chunk分成若干slice, 每个slice都有一个sliceWriter, 每个chunkWriter都有一个commitThread负责后台flush
                sliceWriter.write(off, data) // off表示slice中的offset
                  -> wSlice.WriteAt(p, off) //  将数据写到内存buffer, off表示slice中的offset

commitThread // loop扫描每个slice
  -> sliceWriter.flushData() // 每个slice被freeze后就起一个异步flush线程, 待flush done
    -> sliceWriter.chunkWriter.Finish(length) // length是该slice中冻结的数据长度
      -> wSlice.FlushTo(offset) // flush offset前未upload的数据, 其中, offset是flush的截止偏移
        ->wSlice.upload(index) // index是block在slice中的编号
       chunkWriter.fileWriter.dataWriter.Meta.Write(inode, indx, off, slice) // slice数据flush done之后, 将slice的元数据append到chunk.slices后面, 这里index是file中的chunk编号, off是chunk中的offset

读流程
fileSystem.Read(in fuse.ReadIn, buf []byte)
  -> VFS.Read(Ino(in.NodeId), buf, in.Offset, in.Fh) // 读取文件指定偏移, 这里Offset是file的offset
    -> handle.fileReader.Read(off, buf) // 读取文件对象指定偏移, 这里off是file的offset
      -> fileReader.splitRange(block) // 这里block表示文件的一个区间, 为支持slice读合并, 将block分成若干slice,
          fileReader.prepareRequests(ranges) // 每个slice有一个sliceReader负责读数据, 这里起异步sliceReader
          fileReader.waitForIO(reqs, buf) // 这里req.frange.off是req.sliceReader这个slice中的offset, 这里调用后等待数据ready被唤醒

sliceReader.Run()
  -> sliceReader.fileReader.dataReader.Meta.Read(inode, index, &slices) // sliceReader读取chunk对应的slice列表, 这里index是file中的chunk编号
     sliceReader.fileReader.dataReader.Read(page, slices, offset) // sliceReader读取数据, 这里offset是chunk中的offset
       ->dataReader.readSlice(s *meta.Slice, page *chunk.Page, off int) // 这里off是Slice中的有效offset
         ->rSlice.ReadAt(p Page, off int) // 这里rSlice指特定meta.Slice的读取实体, off是meta.Slice中的offset, p是数据存放地址
     sliceReader.Done() // 数据ready, 唤醒主线程


// pkg/fs/fs.go 定义文件接口
func (f *File) Read(ctx meta.Context, b []byte) (n int, err error) {
	_, task := trace.NewTask(context.TODO(), "Read")
	defer task.End()
	l := vfs.NewLogContext(ctx)
	defer func() { f.fs.log(l, "Read (%s,%d): (%d,%s)", f.path, len(b), n, errstr(err)) }()
	f.Lock()
	defer f.Unlock()
	n, err = f.pread(ctx, b, f.offset) // 这里调用读接口
	f.offset += int64(n)
	return
}

func (f *File) pread(ctx meta.Context, b []byte, offset int64) (n int, err error) {
	if offset >= f.info.Size() {
		return 0, io.EOF
	}
	if int64(len(b))+offset > f.info.Size() {
		b = b[:f.info.Size()-offset]
	}
	if f.data != nil {
		n := copy(b, f.data[offset:])
		return n, nil
	}
	if f.wdata != nil {
		eno := f.wdata.Flush(ctx)
		if eno != 0 {
			err = eno
			return
		}
	}
	if f.rdata == nil {
		f.rdata = f.fs.reader.Open(f.inode, uint64(f.info.Size()))
	}

	got, eno := f.rdata.Read(ctx, uint64(offset), b) // 实际调用vfs.FileReader.Read接口
	for eno == syscall.EAGAIN {
		got, eno = f.rdata.Read(ctx, uint64(offset), b)
	}
	if eno != 0 {
		err = eno
		return
	}
	if got == 0 {
		return 0, io.EOF
	}
	f.fs.readSizeHistogram.Observe(float64(got))
	return got, nil
}

// pkg/vfs/reader.go
func (f *fileReader) Read(ctx meta.Context, offset uint64, buf []byte) (int, syscall.Errno) {
	if f.r.readBufferUsed() > f.r.bufferSize {
		time.Sleep(time.Millisecond * 10)             // slow down
		for f.r.readBufferUsed() > f.r.bufferSize*2 { // readahead uses 80% of buffer, stop here to avoid OOM
			time.Sleep(time.Millisecond * 100)
		}
	}
	f.Lock()
	defer f.Unlock()
	f.acquire()
	defer f.release()

	if f.err != 0 || f.closing {
		return 0, f.err
	}

	size := uint64(len(buf))
	if offset >= f.length || size == 0 {
		return 0, 0
	}
	block := &frange{offset, size}
	if block.end() > f.length {
		block.len = f.length - block.off
	}

	f.cleanupRequests(block)
	var lastBS uint64 = 32 << 10
	if block.off+lastBS > f.length {
		lastblock := frange{f.length - lastBS, lastBS}
		if f.length < lastBS {
			lastblock = frange{0, f.length}
		}
		f.readAhead(&lastblock)
	}
	ranges := f.splitRange(block)
	reqs := f.prepareRequests(ranges)
	defer func() {
		for _, req := range reqs {
			s := req.s
			s.refs--
			if s.refs == 0 && s.state == INVALID {
				s.delete()
			}
		}
	}()
	f.checkReadahead(block)
	return f.waitForIO(ctx, reqs, buf)
}
