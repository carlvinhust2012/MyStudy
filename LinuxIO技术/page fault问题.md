cpu能访问物理内存吗？
CPU 并不直接访问物理内存，而是通过以下步骤间接访问：
CPU 缓存：首先在缓存中查找所需数据。
MMU 和虚拟内存：如果缓存未命中，MMU 将虚拟地址映射为物理地址。
总线和内存控制器：通过总线将请求发送到内存控制器。
物理内存：最终由内存控制器访问物理内存。

当 CPU 访问虚拟内存时，MMU 会根据页表（Page Table）将虚拟地址转换为物理地址。页表是一个数据结构，存储了虚拟地址和物理地址之间的映射关系。
CPU 通过系统总线（如前端总线 FSB 或 QPI）与内存控制器通信，总线是 CPU 和内存控制器之间的数据传输通道；
内存控制器是 CPU 和物理内存之间的桥梁。它负责管理内存的读写操作，并将 CPU 的请求转发到物理内存。
内存控制器会根据多个请求的优先级进行仲裁，确保内存的访问不会冲突。

Linux进程如何访问内存?
Linux下，进程并不是直接访问物理内存，而是通过内存管理单元(MMU)来访问内存资源。

为什么需要虚拟内存地址空间？
假设某个进程需要4MB的空间，内存假设是1MB的，如果进程直接使用物理地址，这个进程会因为内存不足跑不起来。
既然进程不是直接访问物理内存，那么进程中涉及的内存地址当然也不是物理内存地址。
而是虚拟的内存地址，虚拟的内存地址和物理的内存地址之间保持一种映射关系，这种关系由MMU进行管理。
每个进程都有自己独立的虚拟地址空间。

什么是MMU？
MMU全称是内存管理单元，它将物理内存分割成多个pages，MMU管理进程的虚拟地址空间中的PAGE和物理内存中的PAGE之间的映射关系。
因为是映射，所以随时都可能发生变化，例如某个进程虚拟内存空间中的PAGE1，在不同的时间点，可能出现在物理内存中的不同位置（当发生了页交换时）。

什么是page fault？
当进程访问它的虚拟地址空间中的PAGE时，如果这个PAGE目前还不在物理内存中，此时CPU是不能干活的，
Linux会产生一个hard page fault中断。
系统需要从慢速设备（如磁盘）将对应的数据PAGE读入物理内存，并建立物理内存地址与虚拟地址空间PAGE的映射关系。
然后进程才能访问这部分虚拟地址空间的内存。

page fault 又分为几种，major page fault、 minor page fault、 invalid(segment fault)。

major page fault也称为hard page fault, 指需要访问的内存不在虚拟地址空间，也不在物理内存中，需要从慢速设备载入。从swap回到物理内存也是hard page fault。

minor page fault也称为soft page fault, 指需要访问的内存不在虚拟地址空间，但是在物理内存中，只需要MMU建立物理内存和虚拟地址空间的映射关系即可。
（通常是多个进程访问同一个共享内存中的数据，可能某些进程还没有建立起映射关系，所以访问时会出现soft page fault）

invalid fault也称为segment fault, 指进程需要访问的内存地址不在它的虚拟地址空间范围内，属于越界访问，内核会报segment fault错误。
