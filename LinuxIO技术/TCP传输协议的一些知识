1.巨复杂的TCP
1)重传机制
  超时重传
  快速重传
  SACK
  D-ACK

2)滑动窗口
  发送窗口
  接收窗口

3)流量控制
  系统缓冲区与滑动窗口的关系
  窗口关闭
  糊涂窗口综合症

4)拥塞控制
  慢启动
  拥塞避免
  拥塞发生
  快速恢复

2.tcp如何保证可靠传输？
序列号，确认应答，重发控制，连接管理，窗口控制等机制实现可靠传输。

TCP 实现可靠传输的方式之一，是通过序列号与确认应答。在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。

3.重传机制
TCP 针对数据包丢失的情况，会用重传机制解决。
发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传。

TCP 会在以下两种情况发生超时重传：
1)数据包丢失
2)确认应答丢失

3）超时时间应该设置为多少呢？
RTT（Round-Trip Time 往返时延），Syn—syn ack—ack 之间的时延，数据从网络一端传送到另一端所需的时间，也就是包的往返时间。


4）超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示

6）假设在重传的情况下，超时时间 RTO 「较长或较短」时，会发生什么事情呢？

a）当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；

b）当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。

7）超时重传时间 RTO 的值应该略大于报文往返  RTT 的值。

可能大家觉得超时重传时间 RTO 的值计算，也不是很复杂嘛。

好像就是在发送端发包时记下 t0 ，然后接收端再把这个 ack 回来时再记一个 t1，于是 RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。

实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个动态变化的值。

8）我们来看看 Linux 是如何计算 RTO 的呢？

估计往返时间，通常需要采样以下两个：

需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。
除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。



3. 为什么两次就建立连接还要三次握手呢？
这主要是为了防止已失效的连接请求报文又突然传递服务器。
所谓“防止已失效的连接请求报文又突然传递给服务器。”是这样一种情况：
A客户端发出连接请求，因为连接请求报文丢失而未等到确认，于是A再次重传了连接请求，建立了连接，数据传输完毕后，释放了连接。
现在假设那第一个请求只是因为网路节点长时间滞留了，使得它在第二个连接释放后才到达B服务器，
那么B会以为这是一个新的连接请求，于是就向A发了个连接确认，注意了：如果没有最后一次的确认B会一厢情愿的以为连接已经建立，
可人家A同学一看那个B给的是什么呀！跟自己没关系，简单粗暴的丢掉。这时B孩子还傻傻的等着A给他发数据，就这样，B白白浪费的大把的时光和资源。
那B会一直傻等吗？当然不是，它的等待也是有限的，答案就是保活计时器。

3.为什么要有四次挥手的TIME_WAIT的状态?
（1）第一是为了保证最后一个的一个ACK报文能到达B。这个ACK报文有可能丢失，因而使得处在LAST_ACK状态得不到对已发送的FIN+ACK报文的确认，
B会超时重传这个FIN+ACk ,而A就能在这TIME_WAIT时间（2MSL）里收到这个重传的报文，A就可以重传一次确认，如果没有这个TIME_WAIT， 那B重传的FIN_ACK，
可A早就走了，自然不会再重发确认，这样B就无法按照正常步骤进入CLOSE 状态。
（2）第二是防止“已失效的报文连接请求”，A在TIME_WAIT中，经过这2MSL的时间，就可以使本链接持续的时间内产生的所有连接消失，这样就可以使下一个新的连接中
不会出现这样旧的连接请求报文段。
（3）聪明的你会发现谁先关闭谁就有一个TIME_WAIT的状态；
在linux的网络编程中，如果服务器如果先关闭，你会发现，现在想要立马再次启动服务器，就会报错说这个端口号被占用着，那就是因为有这个TIME_WAIT，
2msl的时间.那么怎么解决 ？解决：setsockopt（）函数，在这就不多说了。

close_wait

