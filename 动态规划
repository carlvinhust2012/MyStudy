动态规划的一般形式是求最值，一般也会具有最优子结构，可以画出递归树，求找到最优子结构，使用数据结构将其保存，避免重复计算
----核心问题是穷举，通过穷举去识别出最值
--------穷举的一般存在重叠子问题，暴力穷举效率太低
------------为了实现穷举，并且保证效率最优，就需要借助 备忘录（memo）或者 DP table

一般解题思路：
明确状态--->确定dp表/计算函数--->确定选择---->确定base case

例1：有N级台阶，可以一次跨1步，也可以一次跨2步，请问一共有几种走法？
若只有1级台阶，需要1步；1种走法
若有2级台阶，可以1次1步，走2次；也可以1次2步；2种走法
若有3级台阶，可以1次1步，走3次；也可以1次1步，1次2步，走2次；也可以1次2步，1次1步，走2次；3种走法
若有4级台阶，可以1次1步，走4次；也可以1次1步，1次2步，1次1步，走3次；也可以1次1步，1次1步，1次2步，走3次；
            也可以1次1次2步，1次1步，1次1步，走3次；也可以1次2步，1次2步，走2次；5种走法
f(0) = 0;
f(1) = 1;
f(2) = 2;
f(3) = 3;
f(4) = 5;
.....

f(n) = f(n-1) + f(n-2), where n >= 2 ----斐波那契数列

暴力递归：
// 造成很多重复计算
int fib(int n){
    if(n<=2) return n;
    int x = f(n-1)+f(n-2);
    return x;
}

迭代算法：
// 每次计算后，都保存前面2次的结果
int fib(int n){
    if(n<=2) return n;
    if first=1,second=2;
    int third=0;
    for(int i=3;i<=n;i++){
        third = first+second;
        first = second;
        second = third;
    }
    return third;
}




